/**
 * TNTConcept Easy Enterprise Management by Autentia Real Bussiness Solution S.L.
 * Copyright (C) 2007 Autentia Real Bussiness Solution S.L.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package com.autentia.tnt.manager.commissioning;

import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Set;


import org.apache.commons.lang3.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.autentia.tnt.businessobject.Commissioning;
import com.autentia.tnt.businessobject.CommissioningChange;
import com.autentia.tnt.businessobject.CommissioningDelay;
import com.autentia.tnt.businessobject.CommissioningFile;
import com.autentia.tnt.businessobject.CommissioningPaymentData;
import com.autentia.tnt.businessobject.CommissioningStatus;
import com.autentia.tnt.businessobject.User;
import com.autentia.tnt.dao.SortCriteria;
import com.autentia.tnt.dao.hibernate.CommissioningDAO;
import com.autentia.tnt.dao.search.CommissioningSearch;
import com.autentia.tnt.manager.security.AuthenticationManager;
import com.autentia.tnt.util.ConfigurationUtil;
import com.autentia.tnt.util.SpringUtils;

public class CommissioningManager {

	/* Commissioning - generated by stajanov (do not edit/delete) */

	/** Logger */
	private static final Log log = LogFactory
			.getLog(CommissioningManager.class);

	/** Commissioning DAO **/
	private CommissioningDAO commissioningDAO;

	/**
	 * Get default CommissioningManager as defined in Spring's configuration
	 * file.
	 * 
	 * @return the default singleton CommissioningManager
	 */
	public static CommissioningManager getDefault() {
		return (CommissioningManager) SpringUtils
				.getSpringBean("managerCommissioning");
	}

	/**
	 * Empty constructor needed by CGLIB (Spring AOP)
	 */
	protected CommissioningManager() {
	}

	/**
	 * Default constructor
	 * 
	 * @deprecated do not construct managers alone: use Spring's declared beans
	 */
	public CommissioningManager(CommissioningDAO commissioningDAO) {
		this.commissioningDAO = commissioningDAO;
	}

	/**
	 * List commissionings.
	 * 
	 * @param search
	 *            search filter to apply
	 * @param sort
	 *            sorting criteria
	 * @return the list of all commissionings sorted by requested criterion
	 */
	public List<Commissioning> getAllEntities(CommissioningSearch search,
			SortCriteria sort) {

		final User actualUser = AuthenticationManager.getDefault()
				.getCurrentPrincipal().getUser();
		// FIXME no se si se puede hacer con acegi, pero no deberia hacerse asi
		if (!actualUser.getRole().getId().equals(
				ConfigurationUtil.getDefault().getRoleAdminId())) {

			List<User> reviser = new ArrayList<User>();
			reviser.add(actualUser);
			search.setRevisers(reviser);
		}
        return commissioningDAO.search(search, sort);
	}

	/**
	 * Get commissioning by primary key.
	 * 
	 * @return commissioning selected by id.
	 */
	public Commissioning getEntityById(int id) {
		Commissioning commissioning = commissioningDAO.loadById(id);
		commissioning.initChanges();
		return commissioning;
	}

	/**
	 * Insert commissioning.
	 */
	public void insertEntity(Commissioning commissioning) {
        commissioningDAO.insert(commissioning);
	}

	/**
	 * Update commissioning.
	 */
	public void updateEntity(Commissioning commissioning) {
		if (commissioning.getStatus() == CommissioningStatus.VALIDATED) {
			if (entityChangedInStatus(commissioning, CommissioningStatus.CONFIRMED)) {
				deleteHistory(commissioning);
				commissioning.setStatus(CommissioningStatus.CREATED);
				// para que tampoco se graben los cambios en el histórico
				// ponemos el estado del changes a creado, y nos aseguramos que no
				// se evaluan los cambios
				if (commissioning.getChanges() != null) {
					commissioning.getChanges().setStatus(CommissioningStatus.CREATED);
				}
			}
			// se ha producido un cambio en la fase de confirmacion con lo
			// cual pasa a creado
		}
		
		// get changes for history
		Commissioning changes = commissioning.getChanges();
		
		
		
		commissioningDAO.update(commissioning);
		
		// tracking entity changes
		Commissioning commissioningHibSession = commissioningDAO.loadById(commissioning.getId());
		Commissioning changesHibSession = commissioningHibSession.getChanges();
		commissioningHibSession.setChanges(changes);
		trackEntityChanges(commissioningHibSession);
	}

	/**
	 * Delete commissioning.
	 */
	public void deleteEntity(Commissioning commissioning) {
		commissioningDAO.delete(commissioning);
	}

	/* Commissioning - generated by stajanov (do not edit/delete) */
	
	/**
	 * Mira los campos de la entidad a ver si se han producido cambios
	 * 
	 * @return true si se produjo algun cambio
	 * @throws SecurityException
	 * @throws NoSuchFieldException
	 * @throws IllegalArgumentException
	 * @throws IllegalAccessException
	 */
	private boolean trackEntityChanges(final Commissioning commissioning) {

		final SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yyyy hh:mm:ss");
		final DecimalFormat df = new DecimalFormat("0.00");
		int previousHistorySize = commissioning.getHistory().size();
		int finalHistorySize = previousHistorySize;
		// TODO ¿podría ser por reflexión para obtener los atributos persistentes?
		if ((commissioning.getChanges() != null)
				&& (commissioning.getChanges().getStatus() == CommissioningStatus.ACCEPTED || commissioning
						.getChanges().getStatus() == CommissioningStatus.CONFIRMED)) {
			final Commissioning changes = commissioning.getChanges();

			if (changes.getBudget() != null
					&& !(changes.getBudget().floatValue() == commissioning.getBudget().floatValue())) {
				commissioning.getHistory().add(
						getChange("commissioning.budget", df.format(changes.getBudget()), df.format(commissioning
								.getBudget()), commissioning));
			}

			commissioning.getHistory().add(
					getChange("commissioning.name", changes.getName(), commissioning.getName(), commissioning));

			commissioning.getHistory().add(
					getChange("commissioning.conclusions", changes.getConclusions(), commissioning.getConclusions(),
							commissioning));

			commissioning.getHistory()
					.add(
							getChange("commissioning.content", changes.getContent(), commissioning.getContent(),
									commissioning));

			if (changes.getDeliveryDate() != null && commissioning.getDeliveryDate() != null
					&& changes.getDeliveryDate().getTime() != commissioning.getDeliveryDate().getTime()) {
				commissioning.getHistory().add(
						getChange("commissioning.deliveryDate", sdf
								.format(changes.getDeliveryDate()), sdf
								.format(commissioning.getDeliveryDate()), commissioning));
			}

			commissioning.getHistory().add(
					getChange("commissioning.developedActivities", changes.getDevelopedActivities(), commissioning
							.getDevelopedActivities(), commissioning));

			commissioning.getHistory().add(
					getChange("commissioning.difficultiesAppeared", changes.getDifficultiesAppeared(), commissioning
							.getDifficultiesAppeared(), commissioning));

			commissioning.getHistory().add(
					getChange("commissioning.evaluation", changes.getEvaluation(), commissioning.getEvaluation(),
							commissioning));

			commissioning.getHistory().add(
					getChange("commissioning.notes", changes.getNotes(), commissioning.getNotes(), commissioning));

			commissioning.getHistory().add(
					getChange("commissioning.products", changes.getProducts(), commissioning.getProducts(),
							commissioning));
			

			if (changes.getRequestDate() != null
					&& commissioning.getRequestDate() != null
					&& changes.getRequestDate().getTime() != commissioning
							.getRequestDate().getTime()) {
				commissioning.getHistory().add(
						getChange("commissioning.requestDate", sdf
								.format(changes.getRequestDate()), sdf
								.format(commissioning.getRequestDate()), commissioning));
			}

			commissioning.getHistory()
					.add(
							getChange("commissioning.results", changes.getResults(), commissioning.getResults(),
									commissioning));

			commissioning.getHistory().add(
					getChange("commissioning.scope", changes.getScope(), commissioning.getScope(), commissioning));
			
			if (changes.getStatus() != null && !changes.getStatus().equals(commissioning.getStatus())) {
				commissioning.getHistory().add(
						getChange("commissioning.status", changes.getStatus().toString(), commissioning.getStatus()
								.toString(), commissioning));
			}

			if (changes.isJustifyInformation() != commissioning
					.isJustifyInformation()) {
				commissioning.getHistory().add(
						getChange("commissioning.justifyInformation", Boolean
								.toString(changes.isJustifyInformation()),
								Boolean.toString(commissioning
										.isJustifyInformation()), commissioning));
			}

			if (changes.isAdminSignature() != commissioning.isAdminSignature()) {
				commissioning.getHistory().add(
						getChange("commissioning.adminSignature", Boolean
								.toString(changes.isAdminSignature()), Boolean
								.toString(commissioning.isAdminSignature()), commissioning));
			}

			if (changes.isAuthorSignature() != commissioning
					.isAuthorSignature()) {
				commissioning.getHistory().add(
						getChange("commissioning.authorSignature", Boolean
								.toString(changes.isAuthorSignature()), Boolean
								.toString(commissioning.isAuthorSignature()), commissioning));
			}

			if (changes.isReviserSignature() != commissioning
					.isReviserSignature()) {
				commissioning.getHistory().add(
						getChange("commissioning.reviserSignature", Boolean
								.toString(changes.isReviserSignature()),
								Boolean.toString(commissioning
										.isReviserSignature()), commissioning));
			}
			
			if (changes.getProject() != null && changes.getProject().getName() != null
					&& !changes.getProject().getName().equals(commissioning.getProject().getName())) {
				commissioning.getHistory().add(
						getChange("commissioning.project", changes.getProject().getName().toString(), commissioning
								.getProject().getName().toString(), commissioning));
			}

			commissioning.getHistory().addAll(getRevisersChanges(commissioning));

			commissioning.getHistory().addAll(getFilesChanges(commissioning));

			commissioning.getHistory().addAll(getCommissioningDelaysChanges(commissioning));

			commissioning.getHistory().addAll(getCollaboratorPaymentChanges(commissioning));
			
			finalHistorySize = commissioning.getHistory().size();
		}
		// if has changes previousHistorySize != finalHistorySize
		return previousHistorySize != finalHistorySize;
	}

	private List<CommissioningChange> getRevisersChanges(final Commissioning commissioning) {
		final List<CommissioningChange> changes = new ArrayList<CommissioningChange>();
		for (User user : commissioning.getRevisers()) {
			if (!commissioning.getChanges().getRevisers().contains(user)) {
				changes.add(getChange("commissioning.revisers", "", user
						.getName(), commissioning));
			}
		}
		for (User user : commissioning.getChanges().getRevisers()) {
			if (!commissioning.getRevisers().contains(user)) {
				changes.add(getChange("commissioning.revisers", user.getName(),
						"", commissioning));
			}
		}
		return changes;
	}	
	
	private List<CommissioningChange> getFilesChanges(final Commissioning commissioning) {
		final List<CommissioningChange> changes = new ArrayList<CommissioningChange>();
		for (CommissioningFile file : commissioning.getFiles()) {
			if (!commissioning.getChanges().getFiles().contains(file)) {
				changes.add(getChange("commissioning.files", "", file.getFile(), commissioning));
			}
		}
		for (CommissioningFile file : commissioning.getChanges().getFiles()) {
			if (!commissioning.getFiles().contains(file)) {
				changes.add(getChange("commissioning.files", file.getFile(), "", commissioning));
			}
		}
		return changes;
	}

	 private List<CommissioningChange> getCommissioningDelaysChanges(final Commissioning commissioning) {
		 final List<CommissioningChange> changes = new ArrayList<CommissioningChange>();
		final SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yyyy hh:mm:ss");
		for (CommissioningDelay delay : commissioning.getCommissioningDelays()) {
			if (!commissioning.getChanges().getCommissioningDelays().contains(delay)) {
				changes.add(getChange("commissioningDelay.delayedToDate", "", sdf.format(delay.getDelayedToDate()),
						commissioning));
			}
		}
		for (CommissioningDelay delay : commissioning.getChanges().getCommissioningDelays()) {
			if (!commissioning.getCommissioningDelays().contains(delay)) {
				changes.add(getChange("commissioningDelay.delayedToDate", sdf.format(delay.getDelayedToDate()), "",
						commissioning));
			}
		}
		return changes;
	 }
	 
	 private List<CommissioningChange> getCollaboratorPaymentChanges(final Commissioning commissioning) {
		final List<CommissioningChange> changes = new ArrayList<CommissioningChange>();
		for (CommissioningPaymentData payment : commissioning.getCollaboratorsPaymentData()) {
			// FIXME no debería haber bucle y debería funcionar con el método "contains"
			// metemos el recorrido del bucle en busca del elemento
			// ya que el método contains no está funcionando correctamente
			boolean found = false;
			for (CommissioningPaymentData paymentInSet : commissioning.getChanges().getCollaboratorsPaymentData()) {
				if (paymentInSet.equals(payment)) {
					found = true;
					break;
				}
			}
			// if (!commissioning.getChanges().getCollaboratorsPaymentData().contains(payment)) {
			if (!found) {
				changes.add(getChange("commissioning.collaborators", "", payment.getCollaborator().getName(),
						commissioning));
				changes.add(getChange("commissioning.paymentMode", "", "[" + payment.getCollaborator().getName() + "] "
						+ payment.getPaymentMode().name(), commissioning));
				changes.add(getChange("commissioning.bankAccount", "", "[" + payment.getCollaborator().getName() + "] "
						+ payment.getBankAccount(), commissioning));
				changes.add(getChange("commissioning.billNumber", "", "[" + payment.getCollaborator().getName() + "] "
						+ payment.getBillNumber(), commissioning));
			} else {
				changes.addAll(getCollaboratorPaymentInternalChanges(payment, commissioning, false));
			}
			
		}
		for (CommissioningPaymentData payment : commissioning.getChanges().getCollaboratorsPaymentData()) {
			if (!commissioning.getCollaboratorsPaymentData().contains(payment)) {
				changes.add(getChange("commissioning.collaborators", payment.getCollaborator().getName(), "",
						commissioning));
				changes.add(getChange("commissioning.paymentMode", "[" + payment.getCollaborator().getName() + "] "
						+ payment.getPaymentMode().name(), "", commissioning));
				changes.add(getChange("commissioning.bankAccount", "[" + payment.getCollaborator().getName() + "] "
						+ payment.getBankAccount(), "", commissioning));
				changes.add(getChange("commissioning.billNumber", "[" + payment.getCollaborator().getName() + "] "
						+ payment.getBillNumber(), "", commissioning));
			} else {
				changes.addAll(getCollaboratorPaymentInternalChanges(payment, commissioning, true));
			}
		}
		return changes;
	}
	 
	


	private Collection<? extends CommissioningChange> getCollaboratorPaymentInternalChanges(
			CommissioningPaymentData payment, Commissioning commissioning, boolean paymentIsPrevious) {
		final List<CommissioningChange> changes = new ArrayList<CommissioningChange>();
		CommissioningPaymentData paymentInList = null;
		// recuperamos el colaborador de la lista que coincide con el pasado
		for (CommissioningPaymentData paymentData : commissioning.getCollaboratorsPaymentData()) {
			if (payment.equals(paymentData)) {
				paymentInList = paymentData;
				break;
			}
		}
		if(paymentInList == null){
			throw new IllegalArgumentException ("PaymentInList no localizado");
		}
		// asignamos los valores de antes y despues
		CommissioningPaymentData paymentPrevious = null;
		CommissioningPaymentData paymentNow = null;
		if (paymentIsPrevious) {
			paymentPrevious = payment;
			paymentNow = paymentInList;
		} else {
			paymentPrevious = paymentInList;
			paymentNow = payment;
		}

		// sólo puede haber cambiado el modo de pago, la cuenta y la billnumber
		if (!paymentPrevious.getPaymentMode().equals(paymentNow.getPaymentMode())) {
			changes.add(getChange("commissioning.paymentMode", "[" + payment.getCollaborator().getName() + "] "
					+ paymentPrevious.getPaymentMode().name(), "[" + payment.getCollaborator().getName() + "] "
					+ paymentNow.getPaymentMode().name(), commissioning));
		}
		changes.add(getChange("commissioning.bankAccount", "[" + payment.getCollaborator().getName() + "] "
				+ paymentPrevious.getBankAccount(), "[" + payment.getCollaborator().getName() + "] "
				+ paymentNow.getBankAccount(), commissioning));

		changes.add(getChange("commissioning.billNumber", "[" + payment.getCollaborator().getName() + "] "
				+ paymentPrevious.getBillNumber(), "[" + payment.getCollaborator().getName() + "] "
				+ paymentNow.getBillNumber(), commissioning));

		return changes;
	}

	public CommissioningChange getChange(String field, String oldValue,
			String newValue, final Commissioning commissioning) {
		CommissioningChange change = null;
		if (!StringUtils.equals(oldValue, newValue)) {
			oldValue = StringUtils.defaultIfEmpty(oldValue, "");
			newValue = StringUtils.defaultIfEmpty(newValue, "");
			change = new CommissioningChange();
			change.setCommissioning(commissioning);
			change.setStatus(commissioning.getStatus());
			change.setField(field);
			change.setOldValue(oldValue);
			change.setNewValue(newValue);
			change.setInsertDate(new Date());
			change.setUser(AuthenticationManager.getDefault().getCurrentPrincipal().getUser());
		}
		return change;
	}
	
	private boolean entityChangedInStatus(final Commissioning commissioning, CommissioningStatus status) {

		Set<CommissioningChange> history = commissioning.getHistory();

		for (CommissioningChange change : history) {

			if (change.getStatus() == status && change.getDeleteDate() == null) {

				if (change.getField().matches("commissioning[.].*"))
					return true;

			}

		}

		return false;
	}

	private void deleteHistory(final Commissioning commissioning) {

		Set<CommissioningChange> history = commissioning.getHistory();

		for (CommissioningChange change : history) {
			if (change.getDeleteDate() == null) {
				change.setDeleteDate(new Date());
			}
		}

	}
}
