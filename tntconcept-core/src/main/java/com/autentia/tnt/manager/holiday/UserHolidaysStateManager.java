/**
 * TNTConcept Easy Enterprise Management by Autentia Real Bussiness Solution S.L.
 * Copyright (C) 2007 Autentia Real Bussiness Solution S.L.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package com.autentia.tnt.manager.holiday;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;

import com.autentia.tnt.businessobject.*;
import org.apache.commons.lang.time.DateUtils;

import com.autentia.tnt.dao.hibernate.WorkingAgreementDAO;
import com.autentia.tnt.dao.search.HolidaySearch;
import com.autentia.tnt.dao.search.RequestHolidaySearch;
import com.autentia.tnt.util.SpringUtils;

/* Activity - generated by stajanov (do not edit/delete) */

public class UserHolidaysStateManager {

    public static UserHolidaysStateManager getDefault() {
        return (UserHolidaysStateManager) SpringUtils.getSpringBean("managerUserHolidaysState");
    }

    /**
     * Empty constructor needed by CGLIB (Spring AOP)
     */
    protected UserHolidaysStateManager(){
    }

    /**
     * @return Indica si un día es festivo
     */
    private boolean isHoliday(List<Holiday> fiestas, Date date){
        // ¿ Es fin de semana ?
        Calendar cActual = Calendar.getInstance();
        cActual.setTime(date);
        if((cActual.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY)
                || (cActual.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY)){
            return true;
        }

        Iterator<Holiday> ite = fiestas.iterator();
        Holiday current;

        while(ite.hasNext()){
            current = ite.next();
            if(DateUtils.isSameDay(current.getDate(), date)){
                return true;
            }
        }

        return false;
    }

    /**
     * @return Devuelve el número de días laborables que hay entre dos fechas
     */
    public int getWorkingDays(Date fromDate, Date toDate){
        int total = 0;

        // Evitamos un bucle infinito en el bucle que viene a continuación
        if(fromDate.before(toDate) || DateUtils.isSameDay(fromDate, toDate)){
            HolidaySearch fiestaSearch = new HolidaySearch();
            Date current = (Date) fromDate.clone();

            fiestaSearch.setStartDate(fromDate);
            fiestaSearch.setEndDate(toDate);

            List<Holiday> allFiestas = HolidayManager.getDefault().getAllEntities(fiestaSearch, null);

            Calendar fromYear = Calendar.getInstance();
            Calendar toYear = Calendar.getInstance();
            fromYear.setTime(fromDate);
            toYear.setTime(toDate);

            while(current.before(toDate) || DateUtils.isSameDay(current, toDate)){
                if(!this.isHoliday(allFiestas, current)){
                    total++;
                }
//                current = DateUtils.addDays(current, 1);
                LocalDateTime currentPlusDay = current.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime().plusDays(1);
                current = Date.from(currentPlusDay.atZone(ZoneId.systemDefault()).toInstant());
            }
        }

        return total;
    }

    public UserHolidaysState calculateUserHolidaysState(User user, Date year) {
        final UserHolidaysState userHolidaysState = new UserHolidaysState();
        userHolidaysState.setUser(user);

        final WorkingAgreement workingAgreement = findAgreement(user.getAgreement().getId());
        user.setAgreement(workingAgreement);

        if (year != null) {
            final List<Holiday> holidays = findHolidays(year);
            final List<RequestHoliday> requestHolidays = findRequestedHolidays(year, user);

            final int acceptedVacations = calculateAcceptedVacations(holidays, requestHolidays);
            final int agreementVacations = findVacationsFromAgreement(year, user);
            final int totalYearVacations = calculateTotalPermittedVacations(year, user.getStartDate(), agreementVacations);

            userHolidaysState.setTotalAccepted(acceptedVacations);
            userHolidaysState.setYearAgreementHolidays(agreementVacations);
            userHolidaysState.setTotalYear(totalYearVacations);
        }

        return userHolidaysState;
    }

    private WorkingAgreement findAgreement(Integer id) {
        WorkingAgreementDAO workingAgreementDao = WorkingAgreementDAO.getDefault();
        return workingAgreementDao.loadById(id);
    }

    private List<Holiday> findHolidays(Date year) {
        final HolidayManager holidayManager = HolidayManager.getDefault();

        final Date firstDayOfYear = com.autentia.tnt.util.DateUtils.getFirstDayOfYear(year);
        final Date lastDayOfYear = com.autentia.tnt.util.DateUtils.getLastDayOfYear(year);

        final Calendar calendarFirstDayOfYear = Calendar.getInstance();
        calendarFirstDayOfYear.setTime(firstDayOfYear);
        calendarFirstDayOfYear.add(Calendar.YEAR, -1);

        final Calendar calendarLastDayOfYear = Calendar.getInstance();
        calendarLastDayOfYear.setTime(lastDayOfYear);
        calendarLastDayOfYear.add(Calendar.YEAR, 1);

        final HolidaySearch holidaySearch = new HolidaySearch();
        holidaySearch.setStartDate(calendarFirstDayOfYear.getTime());
        holidaySearch.setEndDate(calendarLastDayOfYear.getTime());

        return holidayManager.getAllEntities(holidaySearch, null);
    }

    private List<RequestHoliday> findRequestedHolidays(Date year, User user) {
        Calendar calendarFirstDayOfYear = Calendar.getInstance();
        Calendar calendarLastDayOfYear = Calendar.getInstance();

        Date firstDayOfYear = com.autentia.tnt.util.DateUtils.getFirstDayOfYear(year);
        calendarFirstDayOfYear.setTime(firstDayOfYear);

        Date lastDayOfYear = com.autentia.tnt.util.DateUtils.getLastDayOfYear(year);
        calendarLastDayOfYear.setTime(lastDayOfYear);

        RequestHolidayManager requestHolidayManager = RequestHolidayManager.getDefault();
        RequestHolidaySearch requestHolidaySearch = new RequestHolidaySearch();
        requestHolidaySearch.setUserRequest(user);
        requestHolidaySearch.setState(HolidayState.ACCEPT);
        requestHolidaySearch.setStartChargeYear(calendarFirstDayOfYear.getTime());
        requestHolidaySearch.setEndChargeYear(calendarLastDayOfYear.getTime());

        return requestHolidayManager.getAllEntities(requestHolidaySearch, null);
    }

    private int calculateAcceptedVacations(
            List<Holiday> holidays,
            List<RequestHoliday> requestedHolidays
    ) {
        int acceptedHolidays = 0;

        for (RequestHoliday requestedHoliday : requestedHolidays) {
            Calendar requestHolidayCalendar = Calendar.getInstance();
            requestHolidayCalendar.setTime(requestedHoliday.getBeginDate());

            while (!requestHolidayCalendar.getTime().after(requestedHoliday.getFinalDate())) {
                if (!isWeekend(requestHolidayCalendar)) {
                    boolean isFiesta = false;

                    for (Holiday holiday : holidays) {
                        Calendar holidayCalendar = Calendar.getInstance();
                        holidayCalendar.setTime(holiday.getDate());

                        if (holidayCalendar.get(Calendar.YEAR) == requestHolidayCalendar.get(Calendar.YEAR)
                                && holidayCalendar.get(Calendar.MONTH) == requestHolidayCalendar.get(Calendar.MONTH)
                                && holidayCalendar.get(Calendar.DAY_OF_MONTH) == requestHolidayCalendar.get(Calendar.DAY_OF_MONTH)) {
                            isFiesta = true;
                        }
                    }

                    if (!isFiesta) {
                        acceptedHolidays++;
                    }
                }

                requestHolidayCalendar.add(Calendar.DAY_OF_MONTH, 1);
            }

        }

        return acceptedHolidays;
    }

    private static boolean isWeekend(Calendar calendar) {
        return calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY || calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY;
    }

    private int findVacationsFromAgreement(Date year, User user) {
        final Calendar currentYearCalendar = Calendar.getInstance();
        currentYearCalendar.setTime(year);

        return user.getAgreement().getTerms()
                .stream()
                .filter((workingAgreementTerms) -> {
                    final Calendar calendar = Calendar.getInstance();
                    calendar.setTime(workingAgreementTerms.getEffectiveFrom());

                    return calendar.get(Calendar.YEAR) <= currentYearCalendar.get(Calendar.YEAR);
                })
                .max(Comparator.comparing(WorkingAgreementTerms::getEffectiveFrom))
                .orElseGet(() -> {
                    WorkingAgreementTerms workingAgreementTerms = new WorkingAgreementTerms();
                    workingAgreementTerms.setVacation(0);
                    return workingAgreementTerms;
                })
                .getVacation();
    }

    private int calculateTotalPermittedVacations(Date year, Date startDate, int vacations) {
        Calendar currentYearCalendar = Calendar.getInstance();
        currentYearCalendar.setTime(year);

        Calendar userBeginCalendar = Calendar.getInstance();
        userBeginCalendar.setTime(startDate);

        int yearCharge = currentYearCalendar.get(Calendar.YEAR);
        int yearContract = userBeginCalendar.get(Calendar.YEAR);

        if (yearCharge == yearContract) {
            // Dividimos los días de cada usuario entre los dias del año.
            double ratio = vacations / 360.0;
            int dayContract = userBeginCalendar.get(Calendar.DAY_OF_YEAR);
            int workedDays = (360 - dayContract);
            double holidayDays = workedDays * ratio;
            double aux = Math.round(holidayDays);
            return (int) aux;
        }

        return vacations;
    }

    /**
     * @return Devuelve el número de dias de vacaciones que le quedan a un usuario
     * en un año
     */
    public int getFreeDays(User user, Date year) {
        UserHolidaysState state = this.calculateUserHolidaysState(user, year);
        return state.getTotalYear() - state.getTotalAccepted();
    }
}
